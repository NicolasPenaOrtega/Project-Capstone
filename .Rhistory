rmse_test$.estimate,
rsme_train_interaction_terms$.estimate,
rsme_test_interaction_terms$.estimate,
lasso_rmse_train_data$.estimate,
lasso_rmse_test_data$.estimate
)
) |>
pivot_longer(
cols = c(RSQ, RMSE),
names_to = "METRIC",
values_to = "VALUE"
)
df_metrics |>
ggplot(aes(x = MODEL, y = VALUE)) +
geom_bar(stat = "identity", aes(fill = EVALUATION), position = "dodge") +
facet_wrap(~ METRIC, scales = "free_y") +
labs(
title = "Model Performance Metrics",
x = "Model",
y = "Value",
fill = "Evaluation"
) +
theme_bw() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
strip.text = element_text(face = "bold"),
legend.position = "bottom",
plot.title = element_text(hjust = 0.5, face = "bold", size = 14)
)
ggplot(lasso_train_predictions) +
stat_qq(aes(sample = RENTED_BIKE_COUNT), color = "green") +
stat_qq(aes(sample = .pred), color = "brown1") +
labs(
title = "Q-Q Plot of Rented Bike Count vs Predictions for train data",
x = "Theoretical Quantiles",
y = "Sample Quantiles"
) +
theme_bw() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 14)
)
ggplot(lasso_test_predictions) +
stat_qq(aes(sample = RENTED_BIKE_COUNT), color = "green") +
stat_qq(aes(sample = .pred), color = "brown1") +
labs(
title = "Q-Q Plot of Rented Bike Count vs Predictions for test data",
x = "Theoretical Quantiles",
y = "Sample Quantiles"
) +
theme_bw() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 14)
)
lasso_rmse_train_data; lasso_rsq_train_data; lasso_rmse_test_data; lasso_rsq_test_data
# 1. Calcular los residuos para los datos de entrenamiento y prueba
lasso_train_predictions <- lasso_train_predictions |>
mutate(residual = RENTED_BIKE_COUNT - .pred)
lasso_test_predictions <- lasso_test_predictions |>
mutate(residual = RENTED_BIKE_COUNT - .pred)
# 2. Visualización de Residuos vs. Valores Predichos (Datos de Entrenamiento)
ggplot(lasso_train_predictions, aes(x = .pred, y = residual)) +
geom_point(alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(
title = "Residuos vs. Predicciones (Datos de Entrenamiento)",
x = "Predicciones del Modelo",
y = "Residuos"
) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
# 3. Visualización de Residuos vs. Valores Predichos (Datos de Prueba)
ggplot(lasso_test_predictions, aes(x = .pred, y = residual)) +
geom_point(alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(
title = "Residuos vs. Predicciones (Datos de Prueba)",
x = "Predicciones del Modelo",
y = "Residuos"
) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
# 4. Visualización de Residuos vs. Variables Predictoras Clave (Ejemplo con Temperatura)
# Puedes repetir este gráfico para otras variables predictoras que consideres importantes
ggplot(lasso_test_predictions, aes(x = TEMPERATURE, y = residual)) +
geom_point(alpha = 0.5) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
labs(
title = "Residuos vs. Temperatura (Datos de Prueba)",
x = "Temperatura",
y = "Residuos"
) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
# 5. Histograma de Residuos (para verificar normalidad de los errores)
ggplot(lasso_test_predictions, aes(x = residual)) +
geom_histogram(binwidth = 50, fill = "skyblue", color = "black") +
labs(
title = "Histograma de Residuos (Datos de Prueba)",
x = "Residuos",
y = "Frecuencia"
) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
# Opcional: Gráfico de densidad de Residuos
ggplot(lasso_test_predictions, aes(x = residual)) +
geom_density(fill = "skyblue", alpha = 0.7) +
labs(
title = "Densidad de Residuos (Datos de Prueba)",
x = "Residuos",
y = "Densidad"
) +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 14))
lasso_rmse_train_data; lasso_rsq_train_data; lasso_rmse_test_data; lasso_rsq_test_data
test_weather_data_generation<-function(){
city_weather_bike_df<-generate_city_weather_bike_data()
stopifnot(length(city_weather_bike_df)>0)
print(city_weather_bike_df)
return(city_weather_bike_df)
}
# Install and import required libraries
require(shiny)
require(ggplot2)
require(leaflet)
require(tidyverse)
require(httr)
require(scales)
# Import model_prediction R which contains methods to call OpenWeather API
# and make predictions
source("model_prediction.R")
test_weather_data_generation<-function(){
city_weather_bike_df<-generate_city_weather_bike_data()
stopifnot(length(city_weather_bike_df)>0)
print(city_weather_bike_df)
return(city_weather_bike_df)
}
test_weather_data_generation
df <- test_weather_data_generation
View(df)
runApp()
# Test generate_city_weather_bike_data() function
city_weather_bike_df <- test_weather_data_generation()
View(city_weather_bike_df)
runApp()
runApp()
runApp()
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
)
cities_max_bike
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LATITUDE = first(LATITUDE),
LONGITUDE = first(LONGITUDE),
)
View(city_weather_bike_df)
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LAT = first(LAT),
LNG = first(LNG),
)
View(cities_max_bike)
View(city_weather_bike_df)
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LAT = first(LAT),
LNG = first(LNG),
BIKE_PREDICTION_LEVEL = BIKE_PREDICTION
)
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LAT = first(LAT),
LNG = first(LNG),
BIKE_PREDICTION_LEVEL = BIKE_PREDICTION_LEVEL
)
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LAT = first(LAT),
LNG = first(LNG)
)
cities_max_bike[BIKE_PREDICTION]
cities_max_bike["BIKE_PREDICTION"]
cities_max_bike[BIKE_PREDICTION]
cities_max_bike$BIKE_PREDICTION
city_weather_bike_df[BIKE_PREDICTION]
city_weather_bike_df["BIKE_PREDICTION"]
city_weather_bike_df["BIKE_PREDICTION"][BIKE_PREDICTION = max(BIKE_PREDICTION, na.rm = TRUE)]
city_weather_bike_df |> filter(CITIES_MAX_BIKE = max(CITIES_MAX_BIKE))
city_weather_bike_df |> filter(CITIES_MAX_BIKE == max(CITIES_MAX_BIKE))
city_weather_bike_df |> filter(CITIES_MAX_BIKE == max(CITIES_MAX_BIKE))
city_weather_bike_df |> filter(BIKE_PREDICTION == max(CITIES_MAX_BIKE))
city_weather_bike_df |> filter(BIKE_PREDICTION == max(BIKE_PREDICTION))
city_weather_bike_df |> filter(BIKE_PREDICTION == max(BIKE_PREDICTION)) |> select(BIKE_PREDICTION_LEVEL)
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LAT = first(LAT),
LNG = first(LNG),
BIKE_PREDICTION_LEVEL = filter(BIKE_PREDICTION == max(BIKE_PREDICTION)) |>
select(BIKE_PREDICTION_LEVEL)
)
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LAT = first(LAT),
LNG = first(LNG),
BIKE_PREDICTION_LEVEL = case_when(
CITIES_MAX_BIKE <= 1000 ~ "small",
CITIES_MAX_BIKE <= 3000 ~ "medium",
TRUE ~ "large"
)
)
View(cities_max_bike)
View(cities_max_bike)
View(cities_max_bike)
View(city_weather_bike_df)
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
summarise(
CITIES_MAX_BIKE = max(BIKE_PREDICTION, na.rm = TRUE),
LABEL = first(LABEL),
DETAILED_LABEL = first(DETAILED_LABEL),
LAT = first(LAT),
LNG = first(LNG),
BIKE_PREDICTION_LEVEL = case_when(
CITIES_MAX_BIKE <= 1000 ~ "small",
CITIES_MAX_BIKE <= 3000 ~ "medium",
TRUE ~ "large"
)
)
setwd("HelpDashboar")
shiny::runApp()
runApp()
runApp()
list_city
runApp()
# Load required libraries
require(leaflet)
source("model_prediction.R")
test_weather_data_generation<-function(){
city_weather_bike_df<-generate_city_weather_bike_data()
stopifnot(length(city_weather_bike_df)>0)
print(city_weather_bike_df)
return(city_weather_bike_df)
}
city_weather_bike_df <- test_weather_data_generation()
list_city <- unique(city_weather_bike_df$CITY_ASCII)
list_city
list_city
c("All", list_city)
runApp()
runApp()
list_city
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(city_weather_bike_df)
runApp()
View(cities_max_bike)
colnames(cities_max_bike)
runApp()
runApp()
runApp()
runApp()
selected_city_data
cities_max_bike
DETAILED_LABEL$DETAILED_LABEL
cities_max_bike$cities_max_bike
cities_max_bike$DETAILED_LABEL
prueba <- cities_max_bike |>
filter(CITY_ASCII == input$city_dropdown)
prueba <- cities_max_bike |>
filter(CITY_ASCII == "Paris")
prueba
df_prueba$DETAILED_LABEL
prueba$DETAILED_LABEL
prueba$DETAILED_LABEL[1]
runApp()
runApp()
runApp()
runApp()
runApp()
View(cities_max_bike)
View(city_weather_bike_df)
runApp()
runApp()
View(cities_max_bike)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
selected_city_data
runApp()
city_name
city_names
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
city_weather_bike_df
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(city_weather_bike_df)
View(city_weather_bike_df)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp('HelpDashboar')
runApp('HelpDashboar')
# Define color factor
color_levels <- colorFactor(c("green", "yellow", "red"),
levels = c("small", "medium", "large"))
# Create another data frame called `cities_max_bike` with each row contains city location info and max bike
# prediction for the city
cities_max_bike <- city_weather_bike_df |>
group_by(CITY_ASCII) |>
filter(BIKE_PREDICTION == max(BIKE_PREDICTION, na.rm = TRUE)) |>
slice_head(n = 1) |>
summarise(
CITIES_MAX_BIKE = first(BIKE_PREDICTION), # Ahora 'first' toma el valor máximo que ya hemos filtrado
LABEL = first(LABEL),
DETAILED_LABEL = first(DETAILED_LABEL),
LAT = first(LAT),
LNG = first(LNG),
BIKE_PREDICTION_LEVEL = case_when(
CITIES_MAX_BIKE <= 1000 ~ "small",
CITIES_MAX_BIKE <= 3000 ~ "medium",
TRUE ~ "large"
),
custom_radius = case_when(
BIKE_PREDICTION_LEVEL == "small" ~ 6,
BIKE_PREDICTION_LEVEL == "medium" ~ 10,
BIKE_PREDICTION_LEVEL == "large" ~ 12,
TRUE ~ 5
)
)
library(tidyverse)
source("model_prediction.R")
setwd("HelpDashboar")
runApp()
library(tidyverse)
source("model_prediction.R")
test_weather_data_generation<-function(){
city_weather_bike_df<-generate_city_weather_bike_data()
stopifnot(length(city_weather_bike_df)>0)
#print(city_weather_bike_df)
return(city_weather_bike_df)
}
# Define a city list
# Test generate_city_weather_bike_data() function
city_weather_bike_df <- test_weather_data_generation()
list_city <- unique(city_weather_bike_df$CITY_ASCII)
# Define color factor
color_levels <- colorFactor(c("green", "yellow", "red"),
levels = c("small", "medium", "large"))
# Define color factor
color_levels <- colorFactor(c("green", "yellow", "red"),
levels = c("small", "medium", "large"))
# Define color factor
color_levels <- colorFactor(palette = c("green", "yellow", "red"),
levels = c("small", "medium", "large"))
runApp()
runApp()
shiny::runApp('Dashboard')
runApp('Dashboard')
setwd("Dashboard")
ls
rsconnect::writeManifest()
shiny::runApp('Dashboard')
runApp('Dashboard')
runApp('Dashboard')
runApp('Dashboard')
runApp('Dashboard')
setwd("/media/nicolasp/Datos")
setwd("/media/nicolasp/Datos")
setwd("/media/nicolasp/Datos")
